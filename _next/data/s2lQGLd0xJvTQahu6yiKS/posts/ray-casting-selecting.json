{"pageProps":{"post":{"title":"在WebGL中使用射线选择模型","date":1534877523000,"slug":"ray-casting-selecting","content":"<p><a href=\"https://arthas.me/demo/ray-casting/index.html\">DEMO</a></p>\n<h2>思路</h2>\n<p>首先要用到摄像机的位置、方向和鼠标在屏幕上的位置来得到射线的起点和方向，然后用得到的射线和模型的每个三角形测试来判断模型是否被选中。</p>\n<h2>构建射线</h2>\n<p>先实现简单的射线类：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Ray</span>(<span class=\"hljs-params\">position, direction</span>) </span>{\n  <span class=\"hljs-built_in\">this</span>.position = position\n  <span class=\"hljs-built_in\">this</span>.direction = direction\n}</code></pre>\n<p>通过<code>camera.position</code>和<code>camera.front</code>可以直接得到一个以摄像机为原地，朝向摄像机正前方的射线。\n然后，根据摄像机的 fov 和鼠标的位置坐标可以计算出鼠标所指方向偏离中心的 x 轴和 y 轴角度。</p>\n<pre><code class=\"hljs language-js\">argl.canvas.addEventListener(<span class=\"hljs-string\">'mousemove'</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =></span> {\n  <span class=\"hljs-keyword\">let</span> angleY = -((e.offsetY * camera.zoom / argl.options.height) - (camera.zoom / <span class=\"hljs-number\">2</span>))\n  <span class=\"hljs-keyword\">let</span> zoomX = (camera.zoom / argl.options.height) * argl.options.width\n  <span class=\"hljs-keyword\">let</span> angleX = (e.offsetX * zoomX / argl.options.width) - (zoomX / <span class=\"hljs-number\">2</span>)\n}</code></pre>\n<p>接下来，再将朝向摄像机正前方的向量在<code>camera.front</code>和<code>camera.right</code>两个向量所在的平面中旋转<code>angleX</code>度，再在旋转后的向量和<code>camera.up</code>两个向量所在的平面中旋转<code>angleY</code>度，就得到了鼠标所指向的方向。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> normalFR = glm.vec3.create()\nglm.vec3.cross(normalFR, camera.front, camera.right)\nglm.vec3.normalize(normalFR, normalFR)\n\n<span class=\"hljs-keyword\">let</span> direction = rotateVec(camera.front, normalFR, glm.glMatrix.toRadian(angleX))\n\n<span class=\"hljs-keyword\">let</span> normalFU = glm.vec3.create()\nglm.vec3.cross(normalFU, direction, camera.up)\nglm.vec3.normalize(normalFU, normalFU)\n\ndirection = rotateVec(direction, normalFU, glm.glMatrix.toRadian(angleY))\n\n<span class=\"hljs-comment\">//平面内向量的旋转，normal为平面的法线，angle为旋转角度</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rotateVec</span>(<span class=\"hljs-params\">vec, normal, angle</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> direction = glm.vec3.create()\n  <span class=\"hljs-keyword\">let</span> t1 = glm.vec3.create()\n  <span class=\"hljs-keyword\">let</span> t2 = glm.vec3.create()\n\n  glm.vec3.normalize(normal, normal)\n\n  glm.vec3.scale(t1, vec, <span class=\"hljs-built_in\">Math</span>.cos(angle))\n  glm.vec3.cross(t2, normal, vec)\n  glm.vec3.scale(t2, t2, <span class=\"hljs-built_in\">Math</span>.sin(angle))\n  glm.vec3.add(direction, t1, t2)\n\n  <span class=\"hljs-keyword\">return</span> direction\n}</code></pre>\n<p>然后就可以构建所需射线了：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> ray = <span class=\"hljs-keyword\">new</span> Ray(camera.position, direction)</code></pre>\n<h2>射线三角形相交检测算法</h2>\n<p>使用的算法为<a href=\"https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm\">Möller–Trumbore intersection algorithm</a></p>\n<p>js 实现如下, 我将其作为 Ray 类的一个方法：</p>\n<pre><code class=\"hljs language-js\">Ray.prototype.intersectsTriangle = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">triangle</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> EPSILON = <span class=\"hljs-number\">0.0000001</span>\n  <span class=\"hljs-keyword\">let</span> edge1 = glm.vec3.create()\n  <span class=\"hljs-keyword\">let</span> edge2 = glm.vec3.create()\n  <span class=\"hljs-keyword\">let</span> h = glm.vec3.create()\n  <span class=\"hljs-keyword\">let</span> s = glm.vec3.create()\n  <span class=\"hljs-keyword\">let</span> q = glm.vec3.create()\n  <span class=\"hljs-keyword\">let</span> a, f, u, v, t\n  <span class=\"hljs-keyword\">let</span> temp = glm.vec3.create()\n\n  glm.vec3.sub(edge1, triangle[<span class=\"hljs-number\">1</span>], triangle[<span class=\"hljs-number\">0</span>])\n  glm.vec3.sub(edge2, triangle[<span class=\"hljs-number\">2</span>], triangle[<span class=\"hljs-number\">0</span>])\n  glm.vec3.cross(h, <span class=\"hljs-built_in\">this</span>.direction, edge2)\n  a = glm.vec3.dot(edge1, h)\n  <span class=\"hljs-keyword\">if</span> (a > -EPSILON &#x26;&#x26; a &#x3C; EPSILON) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n  f = <span class=\"hljs-number\">1</span> / a\n  glm.vec3.sub(s, <span class=\"hljs-built_in\">this</span>.position, triangle[<span class=\"hljs-number\">0</span>])\n  u = f * glm.vec3.dot(s, h)\n  <span class=\"hljs-keyword\">if</span> (u &#x3C; <span class=\"hljs-number\">0.0</span> || u > <span class=\"hljs-number\">1.0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n  glm.vec3.cross(q, s, edge1)\n  v = f * glm.vec3.dot(<span class=\"hljs-built_in\">this</span>.direction, q)\n  <span class=\"hljs-keyword\">if</span> (v &#x3C; <span class=\"hljs-number\">0.0</span> || u + v > <span class=\"hljs-number\">1.0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-comment\">// At this stage we can compute t to find out where the intersection point is on the line.</span>\n  t = f * glm.vec3.dot(edge2, q)\n  <span class=\"hljs-keyword\">if</span> (t > EPSILON) {\n    <span class=\"hljs-comment\">// ray intersection</span>\n    <span class=\"hljs-keyword\">let</span> IntersectionPoint = glm.vec3.create()\n    glm.vec3.scale(temp, <span class=\"hljs-built_in\">this</span>.direction, t)\n    glm.vec3.add(IntersectionPoint, <span class=\"hljs-built_in\">this</span>.position, <span class=\"hljs-built_in\">this</span>.direction)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n  } <span class=\"hljs-comment\">// This means that there is a line intersection but not a ray intersection.</span>\n  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}</code></pre>\n<h2>检测射线与模型是否相交</h2>\n<p>通过循环，使用<code>mesh.indices</code>和<code>mesh.vertices</code>中的数据来构建每一个三角形，再将其坐标变换到世界空间，然后检测他们是否与射线相交</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> flag = <span class=\"hljs-literal\">false</span>\n<span class=\"hljs-keyword\">let</span> len = suzanneMesh.indices.length\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; len; i += <span class=\"hljs-number\">3</span>) {\n  <span class=\"hljs-keyword\">let</span> index = [\n    suzanneMesh.indices[i],\n    suzanneMesh.indices[i + <span class=\"hljs-number\">1</span>],\n    suzanneMesh.indices[i + <span class=\"hljs-number\">2</span>],\n  ]\n  <span class=\"hljs-keyword\">let</span> triangle = [glm.vec3.create(), glm.vec3.create(), glm.vec3.create()]\n  glm.vec3.transformMat4(\n    triangle[<span class=\"hljs-number\">0</span>],\n    [\n      suzanneMesh.vertices[index[<span class=\"hljs-number\">0</span>] * <span class=\"hljs-number\">3</span>],\n      suzanneMesh.vertices[index[<span class=\"hljs-number\">0</span>] * <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">1</span>],\n      suzanneMesh.vertices[index[<span class=\"hljs-number\">0</span>] * <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">2</span>],\n    ],\n    model\n  )\n  glm.vec3.transformMat4(\n    triangle[<span class=\"hljs-number\">1</span>],\n    [\n      suzanneMesh.vertices[index[<span class=\"hljs-number\">1</span>] * <span class=\"hljs-number\">3</span>],\n      suzanneMesh.vertices[index[<span class=\"hljs-number\">1</span>] * <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">1</span>],\n      suzanneMesh.vertices[index[<span class=\"hljs-number\">1</span>] * <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">2</span>],\n    ],\n    model\n  )\n  glm.vec3.transformMat4(\n    triangle[<span class=\"hljs-number\">2</span>],\n    [\n      suzanneMesh.vertices[index[<span class=\"hljs-number\">2</span>] * <span class=\"hljs-number\">3</span>],\n      suzanneMesh.vertices[index[<span class=\"hljs-number\">2</span>] * <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">1</span>],\n      suzanneMesh.vertices[index[<span class=\"hljs-number\">2</span>] * <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">2</span>],\n    ],\n    model\n  )\n\n  <span class=\"hljs-keyword\">if</span> (ray.intersectsTriangle(triangle)) {\n    flag = <span class=\"hljs-literal\">true</span>\n  }\n}</code></pre>\n<p>然后即可利用布尔值<code>flag</code>来添加是否选中模型的效果了，demo 中选中时模型变成红色。</p>\n<h2>完整代码</h2>\n<p><a href=\"https://github.com/Deadalusmask/ArGL/tree/master/examples/pick_test\">Deadalusmask/ArGL/examples/pick_test</a></p>\n<p><a href=\"https://arthas.me/demo/ray-casting/index.html\">DEMO</a></p>"},"prev":{"slug":"Graphic-Basics-3","title":"Graphic Basics 3 着色器","date":1525119270000},"next":{"slug":"global-state-with-hooks","title":"Global state with hooks","date":1562871240000}},"__N_SSG":true}