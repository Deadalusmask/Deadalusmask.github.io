<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" type="image/png" href="/favicon.png"/><meta name="theme-color" content="#000000"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"/><meta name="image" content="/favicon.png"/><title>我理解的计算机图形学 -Arthas.me</title><meta property="og:url" content="https://arthas.me/posts/cg"/><meta property="og:type" content="article"/><meta property="og:title" content="我理解的计算机图形学"/><meta property="og:image" content="/favicon.png"/><meta name="twitter:title" content="我理解的计算机图形学"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:image" content="/favicon.png"/><meta name="twitter:creator" content="@deadalusmask"/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/dd23f042793788fe269b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/dd23f042793788fe269b.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-67279fe62e81e3dbb4fe.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.2113c6061a2f456066a1.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.f771efd637e54964f7dc.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-ff7d19fcc1eef3597074.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bslug%5D-44fb0cf09ad137619ef8.js" as="script"/></head><body><div id="__next"><div class="page"><h3><a href="/">Arthas.me</a> / <a href="/posts">Posts</a> /</h3><h1>我理解的计算机图形学</h1><span>2019.12.20</span><div class="md-content"><h2>backgrounds</h2>
<p>首先需要明确的是，在现实世界中，被人眼/相机观测的到内容都是 2D 的，3D 是双眼效应（Binocular vision）和大脑脑补的结果，包括全息、VR 设备和 3D 电影。
显示设备大多数也是输出 2D 图像（一些烟雾屏幕除外）。</p>
<p>然后是二维图像，一张二维图像由许多像素点组成，每个像素点有自己的颜色，颜色可以由你定义的任何值表示，单通道的灰度图，三个数组成的 rgb 值，还可以附加一个透明度信息，可以使用别的颜色表示系统等。一张矩形的图像由宽*高个像素组成，那么我们的目的就是分别计算这些像素的颜色并将其显示在设备上。</p>
<p>所以我们要做的是实现一个 <code>pixelData => color</code> 的函数（着色函数），然后输入渲染每个像素的需要的数据，就得到了每个像素的颜色。
提供给着色函数的数据分为两类，一类是所有像素共享的，在一次渲染中一致的信息，常用的有当前时间，屏幕尺寸，图片纹理等。另一类是每个像素都不同的信息，主要是像素位置。</p>
<h2>2d</h2>
<p>下面是一个使用<code>div</code>作为显示终端渲染 2D 图形的简单实现，根据像素的位置信息 <code>p(x, y)</code> 以及给定的圆心和半径, 我们可以得到像素位置距圆心的距离，及此像素是否在圆内，然后就可以决定此像素是什么颜色。我们还可以根据当前时间<code>t</code>来变换半径的大小和颜色，效果如下。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> color = <span class="hljs-function">(<span class="hljs-params">r, g, b, a</span>) =></span> {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`rgba(<span class="hljs-subst">${r * <span class="hljs-number">255</span>}</span> , <span class="hljs-subst">${g * <span class="hljs-number">255</span>}</span>, <span class="hljs-subst">${b * <span class="hljs-number">255</span>}</span>, <span class="hljs-subst">${a}</span>)`</span>
}

<span class="hljs-keyword">const</span> container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'app'</span>)
<span class="hljs-keyword">const</span> width = <span class="hljs-number">40</span>
<span class="hljs-keyword">const</span> height = <span class="hljs-number">40</span>
container.style.width = <span class="hljs-string">`<span class="hljs-subst">${width * <span class="hljs-number">4</span>}</span>px`</span>
container.style.height = <span class="hljs-string">`<span class="hljs-subst">${height * <span class="hljs-number">4</span>}</span>px`</span>
<span class="hljs-keyword">const</span> pixels = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(width * height).fill(<span class="hljs-literal">null</span>).map(<span class="hljs-function">() =></span> {
  <span class="hljs-keyword">const</span> pixel = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>)
  container.appendChild(pixel)
  <span class="hljs-keyword">return</span> pixel
})

<span class="hljs-keyword">const</span> render = <span class="hljs-function"><span class="hljs-params">t</span> =></span> {
  <span class="hljs-comment">// circle</span>
  <span class="hljs-keyword">const</span> origin = [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>]
  <span class="hljs-keyword">const</span> ridus = <span class="hljs-built_in">Math</span>.sin(t / <span class="hljs-number">1000</span>) / <span class="hljs-number">4</span> + <span class="hljs-number">0.25</span>

  pixels.forEach(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =></span> {
    <span class="hljs-keyword">const</span> p = [(i % height) / width, <span class="hljs-built_in">Math</span>.floor(i / width) / height]
    <span class="hljs-keyword">let</span> res = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]

    <span class="hljs-comment">// draw circle</span>
    <span class="hljs-keyword">const</span> l = <span class="hljs-built_in">Math</span>.sqrt((p[<span class="hljs-number">0</span>] - origin[<span class="hljs-number">0</span>]) ** <span class="hljs-number">2</span> + (p[<span class="hljs-number">1</span>] - origin[<span class="hljs-number">1</span>]) ** <span class="hljs-number">2</span>)
    <span class="hljs-keyword">if</span> (l &#x3C; ridus) {
      <span class="hljs-comment">// inside circle</span>
      <span class="hljs-keyword">const</span> r = <span class="hljs-built_in">Math</span>.sin(t / <span class="hljs-number">1000</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">0.5</span>
      <span class="hljs-keyword">const</span> g = <span class="hljs-built_in">Math</span>.sin(t / <span class="hljs-number">1000</span> + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">0.5</span>
      <span class="hljs-keyword">const</span> b = <span class="hljs-built_in">Math</span>.sin(t / <span class="hljs-number">1000</span> + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">0.5</span>
      res = [r, g, b, <span class="hljs-number">1</span>]
    }

    v.style.backgroundColor = color(...res)
  })
  requestAnimationFrame(render)
}
requestAnimationFrame(render)</code></pre>
<p><a href="https://codesandbox.io/s/2d-rendering-with-div-d1bc0">Try it on CodeSandbox</a></p>
<h2>3d</h2>
<p>接下来是渲染 3D，我们将 3D 空间中的坐标投影在 2D 平面上。如果是正交投影, 当前像素的颜色就是在屏幕空间当前像素位置在屏幕法线方向上光线的颜色，如果是透视投影，当前像素的颜色就是视点位置在 <em>视点到像素位置</em> 的方向上的光线颜色。</p>
<p>简单实现如下，球在 z 轴的位置根据时间移动，因为没有计算光线，直接使用了法线方向作为颜色输出，<code>rgb</code> 对应法线的 <code>xyz</code> 坐标</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> sphIntersect = <span class="hljs-function">(<span class="hljs-params">ro, rd, center, radius</span>) =></span> {
  <span class="hljs-keyword">const</span> oc = vec3.sub([], ro, center)
  <span class="hljs-keyword">const</span> b = vec3.dot(oc, rd)
  <span class="hljs-keyword">const</span> c = vec3.dot(oc, oc) - radius ** <span class="hljs-number">2</span>
  <span class="hljs-keyword">let</span> h = b ** <span class="hljs-number">2</span> - c

  <span class="hljs-keyword">if</span> (h &#x3C; <span class="hljs-number">0.0</span>) {
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-comment">// no intersection</span>
  } <span class="hljs-keyword">else</span> {
    h = <span class="hljs-built_in">Math</span>.sqrt(h)
    <span class="hljs-keyword">return</span> -b - h
  }
}

<span class="hljs-keyword">const</span> render = <span class="hljs-function"><span class="hljs-params">t</span> =></span> {
  pixels.forEach(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =></span> {
    <span class="hljs-keyword">let</span> res = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
    <span class="hljs-keyword">const</span> p = [(i % height) / width, <span class="hljs-built_in">Math</span>.floor(i / width) / height] <span class="hljs-comment">// 0 ~ 1</span>
    p.forEach(<span class="hljs-function">(<span class="hljs-params">_, i</span>) =></span> (p[i] = p[i] * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>)) <span class="hljs-comment">// -1 ~ 1</span>

    <span class="hljs-comment">// ortho</span>
    <span class="hljs-comment">// const ro = [p[0], p[1], 10]</span>
    <span class="hljs-comment">// const rd = [0, 0, -1]</span>

    <span class="hljs-comment">// perspective</span>
    <span class="hljs-keyword">const</span> ro = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>]
    <span class="hljs-keyword">let</span> rd = vec3.create()
    vec3.sub(rd, [p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>], ro)
    vec3.normalize(rd, rd)

    <span class="hljs-keyword">const</span> center = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (<span class="hljs-built_in">Math</span>.sin(t / <span class="hljs-number">1000</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">0.5</span>) * <span class="hljs-number">5</span>]
    <span class="hljs-keyword">const</span> radius = <span class="hljs-number">0.3</span>
    <span class="hljs-keyword">const</span> d = sphIntersect(ro, rd, center, radius)
    <span class="hljs-keyword">if</span> (d > <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// normal</span>
      <span class="hljs-keyword">const</span> nor = vec3.create()
      <span class="hljs-comment">// nor = normalize(ro + rd * d - center)</span>
      vec3.add(nor, ro, vec3.scale(nor, rd, d))
      vec3.normalize(nor, vec3.sub(nor, nor, center))
      res = [...nor, <span class="hljs-number">1</span>]
    }

    v.style.backgroundColor = color(...res)
  })
  requestAnimationFrame(render)
}
requestAnimationFrame(render)</code></pre>
<p><a href="https://codesandbox.io/s/3d-rendering-with-div-m9knk">Try it on CodeSandbox</a></p>
<p>WebGL</p>
<h2>References</h2>
<p><a href="https://thebookofshaders.com/">The Book of Shaders</a></p>
<p><a href="http://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm">sphere functions</a></p></div><hr class="hr"/><div style="display:flex;justify-content:space-between"><a style="margin-right:24px" href="/posts/global-state-with-hooks">Global state with hooks</a><a></a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"我理解的计算机图形学","date":1576780980000,"slug":"cg","content":"\u003ch2\u003ebackgrounds\u003c/h2\u003e\n\u003cp\u003e首先需要明确的是，在现实世界中，被人眼/相机观测的到内容都是 2D 的，3D 是双眼效应（Binocular vision）和大脑脑补的结果，包括全息、VR 设备和 3D 电影。\n显示设备大多数也是输出 2D 图像（一些烟雾屏幕除外）。\u003c/p\u003e\n\u003cp\u003e然后是二维图像，一张二维图像由许多像素点组成，每个像素点有自己的颜色，颜色可以由你定义的任何值表示，单通道的灰度图，三个数组成的 rgb 值，还可以附加一个透明度信息，可以使用别的颜色表示系统等。一张矩形的图像由宽*高个像素组成，那么我们的目的就是分别计算这些像素的颜色并将其显示在设备上。\u003c/p\u003e\n\u003cp\u003e所以我们要做的是实现一个 \u003ccode\u003epixelData =\u003e color\u003c/code\u003e 的函数（着色函数），然后输入渲染每个像素的需要的数据，就得到了每个像素的颜色。\n提供给着色函数的数据分为两类，一类是所有像素共享的，在一次渲染中一致的信息，常用的有当前时间，屏幕尺寸，图片纹理等。另一类是每个像素都不同的信息，主要是像素位置。\u003c/p\u003e\n\u003ch2\u003e2d\u003c/h2\u003e\n\u003cp\u003e下面是一个使用\u003ccode\u003ediv\u003c/code\u003e作为显示终端渲染 2D 图形的简单实现，根据像素的位置信息 \u003ccode\u003ep(x, y)\u003c/code\u003e 以及给定的圆心和半径, 我们可以得到像素位置距圆心的距离，及此像素是否在圆内，然后就可以决定此像素是什么颜色。我们还可以根据当前时间\u003ccode\u003et\u003c/code\u003e来变换半径的大小和颜色，效果如下。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e color = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003er, g, b, a\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`rgba(\u003cspan class=\"hljs-subst\"\u003e${r * \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e}\u003c/span\u003e , \u003cspan class=\"hljs-subst\"\u003e${g * \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e}\u003c/span\u003e, \u003cspan class=\"hljs-subst\"\u003e${b * \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e}\u003c/span\u003e, \u003cspan class=\"hljs-subst\"\u003e${a}\u003c/span\u003e)`\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container = \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'app'\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e width = \u003cspan class=\"hljs-number\"\u003e40\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e height = \u003cspan class=\"hljs-number\"\u003e40\u003c/span\u003e\ncontainer.style.width = \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${width * \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e}\u003c/span\u003epx`\u003c/span\u003e\ncontainer.style.height = \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${height * \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e}\u003c/span\u003epx`\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pixels = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eArray\u003c/span\u003e(width * height).fill(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e).map(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pixel = \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.createElement(\u003cspan class=\"hljs-string\"\u003e'div'\u003c/span\u003e)\n  container.appendChild(pixel)\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e pixel\n})\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e render = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003et\u003c/span\u003e =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// circle\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e origin = [\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e]\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ridus = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.sin(t / \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e) / \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e0.25\u003c/span\u003e\n\n  pixels.forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ev, i\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e p = [(i % height) / width, \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.floor(i / width) / height]\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e res = [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n\n    \u003cspan class=\"hljs-comment\"\u003e// draw circle\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e l = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.sqrt((p[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] - origin[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]) ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e + (p[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] - origin[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]) ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (l \u0026#x3C; ridus) {\n      \u003cspan class=\"hljs-comment\"\u003e// inside circle\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e r = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.sin(t / \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e) / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e g = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.sin(t / \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e b = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.sin(t / \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e\n      res = [r, g, b, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n    }\n\n    v.style.backgroundColor = color(...res)\n  })\n  requestAnimationFrame(render)\n}\nrequestAnimationFrame(render)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca href=\"https://codesandbox.io/s/2d-rendering-with-div-d1bc0\"\u003eTry it on CodeSandbox\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e3d\u003c/h2\u003e\n\u003cp\u003e接下来是渲染 3D，我们将 3D 空间中的坐标投影在 2D 平面上。如果是正交投影, 当前像素的颜色就是在屏幕空间当前像素位置在屏幕法线方向上光线的颜色，如果是透视投影，当前像素的颜色就是视点位置在 \u003cem\u003e视点到像素位置\u003c/em\u003e 的方向上的光线颜色。\u003c/p\u003e\n\u003cp\u003e简单实现如下，球在 z 轴的位置根据时间移动，因为没有计算光线，直接使用了法线方向作为颜色输出，\u003ccode\u003ergb\u003c/code\u003e 对应法线的 \u003ccode\u003exyz\u003c/code\u003e 坐标\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sphIntersect = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ero, rd, center, radius\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oc = vec3.sub([], ro, center)\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e b = vec3.dot(oc, rd)\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e c = vec3.dot(oc, oc) - radius ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e h = b ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e - c\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (h \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// no intersection\u003c/span\u003e\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    h = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.sqrt(h)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e -b - h\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e render = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003et\u003c/span\u003e =\u003e\u003c/span\u003e {\n  pixels.forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ev, i\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e res = [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e p = [(i % height) / width, \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.floor(i / width) / height] \u003cspan class=\"hljs-comment\"\u003e// 0 ~ 1\u003c/span\u003e\n    p.forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e_, i\u003c/span\u003e) =\u003e\u003c/span\u003e (p[i] = p[i] * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)) \u003cspan class=\"hljs-comment\"\u003e// -1 ~ 1\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e// ortho\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// const ro = [p[0], p[1], 10]\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// const rd = [0, 0, -1]\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e// perspective\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ro = [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e]\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e rd = vec3.create()\n    vec3.sub(rd, [p[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], p[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], ro)\n    vec3.normalize(rd, rd)\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e center = [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, (\u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.sin(t / \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e) / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e) * \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e radius = \u003cspan class=\"hljs-number\"\u003e0.3\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e d = sphIntersect(ro, rd, center, radius)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (d \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e// normal\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nor = vec3.create()\n      \u003cspan class=\"hljs-comment\"\u003e// nor = normalize(ro + rd * d - center)\u003c/span\u003e\n      vec3.add(nor, ro, vec3.scale(nor, rd, d))\n      vec3.normalize(nor, vec3.sub(nor, nor, center))\n      res = [...nor, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n    }\n\n    v.style.backgroundColor = color(...res)\n  })\n  requestAnimationFrame(render)\n}\nrequestAnimationFrame(render)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca href=\"https://codesandbox.io/s/3d-rendering-with-div-m9knk\"\u003eTry it on CodeSandbox\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eWebGL\u003c/p\u003e\n\u003ch2\u003eReferences\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://thebookofshaders.com/\"\u003eThe Book of Shaders\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\"\u003esphere functions\u003c/a\u003e\u003c/p\u003e"},"prev":{"slug":"global-state-with-hooks","title":"Global state with hooks","date":1562871240000},"next":null},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"cg"},"buildId":"s2lQGLd0xJvTQahu6yiKS","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-a98cee78eb8282e29fb6.js"></script><script src="/_next/static/chunks/main-67279fe62e81e3dbb4fe.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.2113c6061a2f456066a1.js" async=""></script><script src="/_next/static/chunks/commons.f771efd637e54964f7dc.js" async=""></script><script src="/_next/static/chunks/pages/_app-ff7d19fcc1eef3597074.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-44fb0cf09ad137619ef8.js" async=""></script><script src="/_next/static/s2lQGLd0xJvTQahu6yiKS/_buildManifest.js" async=""></script><script src="/_next/static/s2lQGLd0xJvTQahu6yiKS/_ssgManifest.js" async=""></script></body></html>